#!/usr/bin/env rua
-- I can't believe how slow this goes in numo9
local template = require 'template'
local gl = require 'gl'
local glreport = require 'gl.report'
local GLTex2D = require 'gl.tex2d'
local GLPingPong = require 'gl.pingpong'
local GLSceneObject = require 'gl.sceneobject'
local GLGeometry = require 'gl.geometry'
local GLFBO = require 'gl.fbo'

local App = require 'glapp':subclass()

App.title = 'MoldWars'

-- tex and update size:
local texWidth, texHeight = 256, 256
App.width = texWidth * 3
App.height = texHeight * 3

App.initGL = |:|do
	local len = texWidth * texHeight
	self.texData = ffi.new('uint32_t[?]', len)
	for i=0,len-1 do
		self.texData[i] = math.random(0, 0xffffffff)
	end
	self.tex = GLPingPong{
		--numBuffers = 1,	-- works with 1 or 2 buffers
		numBuffers = 2,	-- works with 1 or 2 buffers
		width = texWidth,
		height = texHeight,
		internalFormat = gl.GL_RGBA,
		magFilter = gl.GL_NEAREST,
		minFilter = gl.GL_NEAREST,
		wrap = {
			s = gl.GL_REPEAT,
			t = gl.GL_REPEAT,
		},
		data = self.texData,
	}
	self.geometry = GLGeometry{
		mode = gl.GL_TRIANGLE_STRIP,
		vertexes = {
			data = {
				0, 0,
				1, 0,
				0, 1,
				1, 1,
			},
			dim = 2,
		},
	}
	self.drawObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
in vec2 vertex;
out vec2 tcv;
void main() {
	gl_Position = vec4(vertex * 2. - 1., 0., 1.);
	tcv = vertex;
}
]],
			fragmentCode = [[
uniform sampler2D tex;
in vec2 tcv;
out vec4 fragColor;
void main() {
	fragColor = texture(tex, tcv, 0);
}
]],
			uniforms = {
				tex = 0,
			},
		},
		texs = {
			self.tex:prev(),
		},
		geometry = self.geometry,
	}
	self.updateObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
in vec2 vertex;
out vec2 tcv;
void main() {
	gl_Position = vec4(vertex * 2. - 1., 0., 1.);
	tcv = vertex;
}
]],
			fragmentCode = template([[
uniform sampler2D tex;
uniform vec3 noiseOfs;
in vec2 tcv;
out vec4 fragColor;

// https://stackoverflow.com/a/34223787
float random(vec2 st) {
	return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
	int noise = int(255. * (random(noiseOfs.xy + tcv) + noiseOfs.z - 1.));
	vec2 tcsrc = tcv;
	if ((noise & 2) == 0) {
		if ((noise & 1) == 0) {
			tcsrc.x += <?=1/texWidth?>;
		} else {
			tcsrc.x -= <?=1/texWidth?>;
		}
	} else {
		if ((noise & 1) == 0) {
			tcsrc.y += <?=1/texHeight?>;
		} else {
			tcsrc.y -= <?=1/texHeight?>;
		}
	}
	fragColor = texture(tex, tcsrc, 0);

	// now we need 3x 3 random variables = random # from 0-26
	// x our 4 above = 108 total, so we aren't passing 127 let alone 255
	int rch = noise >> 2;
	fragColor.r += float((rch % 3) - 1) / 256.;
	rch /= 3;
	fragColor.g += float((rch % 3) - 1) / 256.;
	rch /= 3;
	fragColor.b += float((rch % 3) - 1) / 256.;
	//fragColor.a += r3-1
	fragColor = mod(fragColor, vec4(1., 1., 1., 1.));
}
]], {
	texWidth = texWidth,
	texHeight = texHeight,
}),
			uniforms = {
				tex = 0,
			},
		},
		uniforms = {
			noiseOfs = {0,0,0},
		},
		texs = {
			self.tex:prev(),
		},
		geometry = self.geometry,
	}

	self.fbo = GLFBO{
		dest = self.tex:cur(),
	}:unbind()
end

local lastTime = timer.getTime()
local fpsFrames = 0
local fpsSeconds = 0
local drawsPerSecond = 0

App.update = |:|do
	local thisTime = timer.getTime()
	local deltaTime = thisTime - lastTime
	fpsFrames = fpsFrames + 1
	fpsSeconds = fpsSeconds + deltaTime
	if fpsSeconds > 1 then
		print('FPS: '..(fpsFrames / fpsSeconds))
		drawsPerSecond = 0
		fpsFrames = 0
		fpsSeconds = 0
	end
	lastTime = thisTime

	self.fbo:bind()
	gl.glViewport(0, 0, texWidth, texHeight)
	self.updateObj.uniforms.noiseOfs[1] = math.random()
	self.updateObj.uniforms.noiseOfs[2] = math.random()
	self.updateObj.uniforms.noiseOfs[3] = math.random()
	self.updateObj:draw()

	-- [[ only needed for #self.tex.hist > 1
	self.tex:swap()
	self.fbo:setColorAttachment(self.tex:cur())
	self.updateObj.texs[1] = self.tex:prev()
	self.drawObj.texs[1] = self.tex:prev()
	--]]

	self.fbo:unbind()
	gl.glViewport(0, 0, self.width, self.height)
	
	self.drawObj:draw()
glreport'here'
end
App():run()
