#!/usr/bin/env rua
-- I can't believe how slow this goes in numo9
local template = require 'template'
local gl = require 'gl.setup'(cmdline.gl)
local GLTex2D = require 'gl.tex2d'
local GLPingPong = require 'gl.pingpong'
local GLSceneObject = require 'gl.sceneobject'
local GLGeometry = require 'gl.geometry'
local GLFramebuffer = require 'gl.framebuffer'

local App = require 'glapp':subclass()

App.title = 'MoldWars'

-- tex and update size:
local texWidth, texHeight = 256, 256
App.width = texWidth * 3
App.height = texHeight * 3

App.initGL = |:|do
	local len = texWidth * texHeight
	self.texData = ffi.new('uint32_t[?]', len)
	for i=0,len-1 do
		self.texData[i] = math.random(0, 0xffffffff)
	end
	self.tex = GLPingPong{
		--numBuffers = 1,	-- works with 1 or 2 buffers
		numBuffers = 2,	-- works with 1 or 2 buffers
		width = texWidth,
		height = texHeight,
		internalFormat = gl.GL_RGBA8UI,
		magFilter = gl.GL_NEAREST,
		minFilter = gl.GL_NEAREST,
		wrap = {
			s = gl.GL_REPEAT,
			t = gl.GL_REPEAT,
		},
		data = self.texData,
	}
	self.geometry = GLGeometry{
		mode = gl.GL_TRIANGLE_STRIP,
		vertexes = {
			data = {
				0, 0,
				1, 0,
				0, 1,
				1, 1,
			},
			dim = 2,
		},
	}
	self.drawObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
in vec2 vertex;
out vec2 tcv;
void main() {
	gl_Position = vec4(vertex * 2. - 1., 0., 1.);
	tcv = vertex;
}
]],
			fragmentCode = [[
precision highp usampler2D;	// needed by #version 300 es
uniform usampler2D tex;
in vec2 tcv;
out vec4 fragColor;
void main() {
	fragColor = (1./255.) * vec4(texture(tex, tcv, 0.));
}
]],
			uniforms = {
				tex = 0,
			},
		},
		texs = {
			self.tex:prev(),
		},
		geometry = self.geometry,
	}
	self.updateObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
in vec2 vertex;
void main() {
	gl_Position = vec4(vertex * 2. - 1., 0., 1.);
}
]],
			fragmentCode = template([[
precision highp usampler2D;	// needed by #version 300 es
uniform usampler2D tex;
uniform vec3 noiseOfs;
out uvec4 fragColor;

// https://stackoverflow.com/a/34223787
float random(vec2 st) {
	return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
}

void main() {
	// TODO better randomization
	uint noise = uint(63. * (random(noiseOfs.xy + vec2(gl_FragCoord.xy) / vec2(textureSize(tex, 0))) + noiseOfs.z - 1.));
	ivec2 itc = ivec2(gl_FragCoord);
	if ((noise & 2u) == 0u) {
		if ((noise & 1u) == 0u) {
			itc.x++;
		} else {
			itc.x--;
		}
		itc.x %= <?=texWidth?>;
		itc.x += <?=texWidth?>;
		itc.x %= <?=texWidth?>;
	} else {
		if ((noise & 1u) == 0u) {
			itc.y++;
		} else {
			itc.y--;
		}
		itc.y %= <?=texHeight?>;
		itc.y += <?=texHeight?>;
		itc.y %= <?=texHeight?>;
	}
	fragColor = texelFetch(tex, itc, 0);

	// now we need 3x 3 random variables = random # from 0-26
	// x our 4 above = 108 total, so we aren't passing 127 let alone 255
	uint rch = noise >> 2u;
	fragColor.r += (rch % 3u) - 1u;
	fragColor.r &= 0xFFu;
	rch /= 3u;
	fragColor.g += (rch % 3u) - 1u;
	fragColor.g &= 0xFFu;
	rch /= 3u;
	fragColor.b += (rch % 3u) - 1u;
	fragColor.b &= 0xFFu;
	//fragColor.a += r3-1
	//fragColor.a &= 0xFF;
}
]], {
	texWidth = texWidth,
	texHeight = texHeight,
}),
			uniforms = {
				tex = 0,
			},
		},
		uniforms = {
			noiseOfs = {0,0,0},
		},
		texs = {
			self.tex:prev(),
		},
		geometry = self.geometry,
	}

	self.fbo = GLFramebuffer{
		dest = self.tex:cur(),
	}:unbind()
end

local lastTime = timer.getTime()
local fpsFrames = 0
local fpsSeconds = 0
local drawsPerSecond = 0

App.update = |:|do
	local thisTime = timer.getTime()
	local deltaTime = thisTime - lastTime
	fpsFrames = fpsFrames + 1
	fpsSeconds = fpsSeconds + deltaTime
	if fpsSeconds > 1 then
		print('FPS: '..(fpsFrames / fpsSeconds))
		drawsPerSecond = 0
		fpsFrames = 0
		fpsSeconds = 0
	end
	lastTime = thisTime

	self.fbo:bind()
	gl.glViewport(0, 0, texWidth, texHeight)
	self.updateObj.uniforms.noiseOfs[1] = math.random()
	self.updateObj.uniforms.noiseOfs[2] = math.random()
	self.updateObj.uniforms.noiseOfs[3] = math.random()
	self.updateObj:draw()

	-- [[ only needed for #self.tex.hist > 1
	self.tex:swap()
	self.fbo:setColorAttachment(self.tex:cur())
	self.updateObj.texs[1] = self.tex:prev()
	self.drawObj.texs[1] = self.tex:prev()
	--]]

	self.fbo:unbind()
	gl.glViewport(0, 0, self.width, self.height)
	
	self.drawObj:draw()
end
App():run()
