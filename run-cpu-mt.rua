#!/usr/bin/env rua
local template = require 'template'
local gl = require 'gl'
local GLTex2D = require 'gl.tex2d'
local GLSceneObject = require 'gl.sceneobject'

local ThreadPool = require 'thread.pool'

-- tex and update size:
local texWidth, texHeight = 256, 256
local texelCount = texWidth * texHeight
texData = ffi.new('uint32_t[?]', texelCount)

local pool = ThreadPool{
	-- worker init:
	threadInit = |thread|do
		thread.lua.global.texData = texData+0	-- convert to pointer first
	end,
	-- worker body:
	code = |pool, i| do
		local startRow = math.floor(i / pool.size * texHeight)		-- inclusive
		local endRow = math.floor((i+1) / pool.size * texHeight)	-- exclusive
		local workSize = (endRow - startRow) * texWidth
		local threadOffset = startRow * texWidth
		return template([===[
for localIndex = 0,<?=workSize?>-1 do
	local i = <?=threadOffset?> + localIndex
	local di = math.random(0,3)
	di = ((di & 2) - 1) * ((di & 1) * (<?=texWidth?> - 1) + 1)
	local src = texData[(i + di) % <?=texelCount?>]
	local r = (src + math.random(0,2) - 1) & 0xff
	local g = (src + ((math.random(0,2)-1) << 8)) & 0xff00
	local b = (src + ((math.random(0,2)-1) << 16)) & 0xff0000
	texData[i] = r | g | b
end
]===], 	{
			texWidth = texWidth,
			texelCount = texelCount,
			workSize = workSize,
			threadOffset = threadOffset,
		})
	end,
}

local App = require 'glapp':subclass()
App.title = 'MoldWars'

App.width = texWidth * 3
App.height = texHeight * 3

App.initGL = |:|do
	for i=0,texelCount-1 do
		texData[i] = math.random(0, 0xffffffff)
	end
	self.tex = GLTex2D{
		width = texWidth,
		height = texHeight,
		internalFormat = gl.GL_RGBA,
		magFilter = gl.GL_NEAREST,
		minFilter = gl.GL_NEAREST,
		data = texData,
	}
	self.sceneObj = GLSceneObject{
		program = {
			version = 'latest',
			precision = 'best',
			vertexCode = [[
in vec2 vertex;
out vec2 tcv;
void main() {
	gl_Position = vec4(vertex * 2. - 1., 0., 1.);
	tcv = vertex;
}
]],
			fragmentCode = [[
uniform sampler2D tex;
in vec2 tcv;
out vec4 fragColor;
void main() {
	fragColor = texture(tex, tcv);
}
]],
			uniforms = {
				tex = 0,
			},
		},
		vertexes = {
			data = {
				0, 0,
				1, 0,
				0, 1,
				1, 1,
			},
			dim = 2,
		},
		geometry = {
			mode = gl.GL_TRIANGLE_STRIP,
		},
	}
	self.sceneObj.program:use()
	self.sceneObj.vao:bind()
end

local lastTime = timer.getTime()
local fpsFrames = 0
local fpsSeconds = 0
local drawsPerSecond = 0

App.update = |:|do
	local thisTime = timer.getTime()
	local deltaTime = thisTime - lastTime
	fpsFrames += 1
	fpsSeconds = fpsSeconds + deltaTime
	if fpsSeconds > 1 then
		print('FPS: '..(fpsFrames / fpsSeconds))
		drawsPerSecond = 0
		fpsFrames = 0
		fpsSeconds = 0
	end
	lastTime = thisTime

	pool:cycle()

	self.tex:subimage()
	self.sceneObj.geometry:draw()
end
App():run()
pool:closed()
pool:showErrs()
